--- a/config.c
+++ b/config.c
@@ -53,22 +53,25 @@ config_section_idx(struct uci_section *s
 }
 
 static int
-config_parse_bridge_interface(struct uci_section *s)
+config_parse_bridge_interface(struct uci_section *s, struct device_type *devtype)
 {
-	char *name;
+	char *name = NULL;
+
+	// combine device type prefix and interface name to device name
+	if (asprintf(&name, "%s-%s", devtype->name_prefix, s->e.name) == -1)
+		return -EINVAL;
 
-	name = alloca(strlen(s->e.name) + 4);
-	sprintf(name, "br-%s", s->e.name);
 	blobmsg_add_string(&b, "name", name);
 
-	uci_to_blob(&b, s, bridge_device_type.config_params);
-	if (!device_create(name, &bridge_device_type, b.head)) {
+	uci_to_blob(&b, s, devtype->config_params);
+	if (!device_create(name, devtype, b.head)) {
 		D(INTERFACE, "Failed to create bridge for interface '%s'\n", s->e.name);
 		return -EINVAL;
 	}
 
 	blob_buf_init(&b, 0);
 	blobmsg_add_string(&b, "ifname", name);
+
 	return 0;
 }
 
@@ -79,6 +82,7 @@ config_parse_interface(struct uci_sectio
 	const char *type = NULL, *disabled;
 	struct blob_attr *config;
 	bool bridge = false;
+	struct device_type *devtype;
 
 	disabled = uci_lookup_option_string(uci_ctx, s, "disabled");
 	if (disabled && !strcmp(disabled, "1"))
@@ -86,12 +90,18 @@ config_parse_interface(struct uci_sectio
 
 	blob_buf_init(&b, 0);
 
-	if (!alias)
+	if (!alias) {
 		type = uci_lookup_option_string(uci_ctx, s, "type");
-	if (type && !strcmp(type, "bridge")) {
-		if (config_parse_bridge_interface(s))
+		if (!type)
 			return;
 
+		// lookup type and see if it supports bridge functionality
+		devtype = device_type_get(type, true);
+		if (!devtype)
+			return;
+
+		if (config_parse_bridge_interface(s, devtype))
+			return;
 		bridge = true;
 	}
 
@@ -169,18 +179,8 @@ config_init_devices(void)
 			continue;
 
 		type = uci_lookup_option_string(uci_ctx, s, "type");
-		if (type) {
-			if (!strcmp(type, "8021ad"))
-				devtype = &vlandev_device_type;
-			else if (!strcmp(type, "8021q"))
-				devtype = &vlandev_device_type;
-			else if (!strcmp(type, "bridge"))
-				devtype = &bridge_device_type;
-			else if (!strcmp(type, "macvlan"))
-				devtype = &macvlan_device_type;
-			else if (!strcmp(type, "tunnel"))
-				devtype = &tunnel_device_type;
-		}
+		if (type)
+			devtype = device_type_get(type, false);
 
 		if (devtype)
 			params = devtype->config_params;
--- a/device.c
+++ b/device.c
@@ -24,10 +24,13 @@
 #include <netinet/ether.h>
 #endif
 
+#include <libubox/list.h>
+
 #include "netifd.h"
 #include "system.h"
 #include "config.h"
 
+static struct list_head devtypes;
 static struct avl_tree devices;
 static bool default_ps = true;
 
@@ -60,6 +63,49 @@ const struct uci_blob_param_list device_
 
 static int __devlock = 0;
 
+int device_type_add(struct device_type *devtype)
+{
+	if (device_type_get(devtype->name, false)) {
+		fprintf(stderr, "Did not add device handler '%s': exists already\n",
+			devtype->name);
+		return 1;
+	}
+
+	list_add(&devtype->list, &devtypes);
+	return 0;
+}
+
+/* initialize device type list and add known types */
+static void __init devtypes_init(void)
+{
+	INIT_LIST_HEAD(&devtypes);
+	device_type_add(&simple_device_type);
+	device_type_add(&bridge_device_type);
+	device_type_add(&tunnel_device_type);
+	device_type_add(&macvlan_device_type);
+	device_type_add(&vlandev_device_type);
+}
+
+/* Retrieve the device type for the given name. If 'bridge' is true, the type
+ * must support bridge functionality
+ */
+struct device_type *
+device_type_get(const char *tname, bool bridge)
+{
+	struct device_type *cur;
+
+	list_for_each_entry(cur, &devtypes, list) {
+		if (!strcmp(cur->name, tname)) {
+			if (bridge)
+				return cur->bridge_support ? cur : NULL;
+			else
+				return cur;
+		}
+	}
+
+	return NULL;
+}
+
 void device_lock(void)
 {
 	__devlock++;
--- a/device.h
+++ b/device.h
@@ -221,6 +221,8 @@ extern struct device_type vlandev_device
 void device_lock(void);
 void device_unlock(void);
 
+int device_type_add(struct device_type *devtype);
+struct device_type *device_type_get(const char *tname, bool bridge);
 struct device *device_create(const char *name, struct device_type *type,
 	struct blob_attr *config);
 void device_init_settings(struct device *dev, struct blob_attr **tb);
